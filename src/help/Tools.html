<html>
<title>RARS 1.6 help contents
</title>
<body>
<center>
<h3>RARS - RISC-V Assembler and Runtime Simulator</h3>
<h4>Release 1.0</h4>
<h4>August 2017</h4>
<h4>Cool Capability: Plug-in Tools</h4>
</center>

RARS is capable of running externally-developed software that interacts with an executing
program and system resources.
The requirements for such a program are:
<ol>
<li>It implements the <tt>rars.tools.Tool</tt> interface.
<li>It is part of the <tt>rars.tools</tt> package.
<li>It compiles cleanly into a ".class" file, stored in the <tt>rars/tools</tt> directory.
</ol>

RARS will detect all qualifying tools upon startup and include them in
its Tools menu. 
When a tool's menu item is selected, an instance of it will be created using its no-argument
constructor and its <tt>action()</tt> method will be invoked.
If no qualifying tools are found at startup, the Tools menu will not
appear.  

<p>To use such a tool, load and assemble a program of interest then select the desired tool
from the Tools menu.  The tool's window will open and depending on how it is written it will either
need to be "connected" to the program by clicking a button or will already be connected.  Run
the program as you normally would, to initiate tool interaction with the executing program.

<p>The abstract class <tt>rars.tools.AbstractToolAndApplication</tt>
is included in the RARS distribution to provide
a substantial framework for implementing your own Tool.  A subclass that extends it by
implementing at least its two abstract methods can be run not only from the Tools menu but also
as a free-standing application that uses the RARS assembler and simulator in the background.

<p>Several Tools developed by subclassing <tt>AbstractMarsToolAndApplication</tt> are included
with RARS: an Introduction to Tools, a Data Cache Simulator, a Memory Reference Visualizer, and
a Floating Point tool.  The last one is quite useful even when not connected to a program
because it displays binary, hexadecimal and decimal representations for a 32 bit floating point
value; when any of them is modified the other two are updated as well.

<h4>Adding more system calls</h4>

System calls (<tt>ecall</tt> instruction) are implemented using
a technique similar to that for tools.  This permits anyone to add a new syscall by defining
a new class that meets these requirements:
<ol>
    <li>It extends the <tt>rars.riscv.AbstractSyscall</tt> class.</li>
    <li>It is part of the <tt>rars.riscv.syscalls</tt> package.</li>
    <li>It compiles cleanly into a ".class" file, stored in the
    <tt>rars/riscv/syscalls</tt> directory.</li>
    <li>An entry is added to Syscall.properties</li>
</ol>

<h4>Extending the instruction set</h4>

You can add customized pseudo-instructions to the instruction set by editing
the <tt>PseudoOps.txt</tt>. Instruction specification formats are explained in the file itself.
The specification of a pseudo-instruction is one line long.  It consists of
an example of the instruction, constructed using available instruction specification symbols, followed by a semicolon-separated
list of the basic instructions it will expand to.  Each is an instruction template
constructed using 
instruction specification symbols combined with special template
specification symbols.  The latter permit substitution at program 
assembly time of operands from the user's program into the expanded
pseudo-instruction.

<p><tt>PseudoOps.txt</tt> is read and processed at startup, and error messages will
be produced if a specification is not correctly formatted.  Note that if you wish to
edit it you first have to extract it from the JAR file.
</body>
</html>